Rust implementation - python (parallel vs. serial vs. vectorized calculation of log likelihood)

Components:
rust_datagen_py.py (1)
rust_VFI_py.py (2)
rust_serial_py.py (3)
rust_mp_py.py (4)
rust_res_stack_py.py (5)


(1) intakes Dan's Rust dataset (N=10^3) and duplicates it, generating a list of datasets of N=10^3,...10^8.
(2) solves the dynamic programming problem, given a guess of parameters, to calculate choice-specific value functions at each age.
(Naturally, if we were iterating over a search over parameters, the value function iteration would need to be performed for each guess of parameters, and the parallelized log likelihood calculation would be done with each iteration of the search. Our implementation simulates one such iteration.)
(3) performs the log likelihood calculation for each observation by (a) a vectorized calculation over all observations together and (b) a serial for-loop over index i in N. This is done for each dataset in the list generated by (1) and records the calculation times.
(4) uses multiprocessing Pool to calculate the likelihood for observations in parallel, and is thus a parallelized version of the loop in (3b).  Using 2, 4, 6, 8, and 16 processors, the calculation time is recorded for each dataset in the list generated by (1).
(5) calls all of the above programs, concatenates and then outputs the resulting runtimes.
